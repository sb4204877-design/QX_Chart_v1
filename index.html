<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>QXChart Mobile</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
}
body {
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  background: #0f172a;
  color: #cbd5e1;
  overflow: hidden;
  height: 100vh;
  width: 100vw;
  touch-action: none;
}
#chart-container {
  width: 100%;
  height: 100%;
  position: relative;
  background: #0f172a;
}
canvas {
  display: block;
  position: absolute;
}
#main-canvas {
  top: 0;
  left: 0;
  cursor: crosshair;
}
#price-canvas {
  right: 0;
  top: 0;
  width: 50px;
  background: #0f172a;
  border-left: 1px solid #334155;
  z-index: 10;
}
#time-canvas {
  bottom: 0;
  left: 0;
  height: 25px;
  background: #0f172a;
  border-top: 1px solid #334155;
  z-index: 10;
}
#corner {
  position: absolute;
  bottom: 0;
  right: 0;
  width: 50px;
  height: 25px;
  background: #0f172a;
  border-left: 1px solid #334155;
  border-top: 1px solid #334155;
  z-index: 10;
}

/* Loading Spinner */
#loading {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  z-index: 1000;
}
.spinner {
  width: 28px;
  height: 28px;
  border: 2px solid rgba(51, 65, 85, 0.5);
  border-top-color: #4dffcc;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: 0 auto 8px;
}
@keyframes spin { to { transform: rotate(360deg); } }

/* Menu Button - TOP LEFT */
#menu-button {
  position: absolute;
  top: 6px;
  left: 6px;
  width: 32px;
  height: 32px;
  background: rgba(15, 23, 42, 0.9);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(51, 65, 85, 0.5);
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 200;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}
#menu-button:active {
  transform: scale(0.95);
}

/* Square Menu Icon */
.square-menu-icon {
  width: 16px;
  height: 16px;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  align-items: center;
  padding: 1px 0;
}
.square-menu-icon .line {
  width: 12px;
  height: 1.5px;
  background: #cbd5e1;
  border-radius: 1px;
}

/* Modal Overlay */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: flex-end;
  justify-content: center;
  z-index: 1000;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0.3s ease;
}
.modal-overlay.active {
  opacity: 1;
  visibility: visible;
}

/* Modal Card */
.modal-card {
  background: #1e293b;
  border: 1px solid #334155;
  border-radius: 16px 16px 0 0;
  width: 100%;
  max-height: 70vh;
  overflow: hidden;
  box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.5);
  transform: translateY(100%);
  transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
.modal-overlay.active .modal-card {
  transform: translateY(0);
}
.modal-header {
  padding: 12px 16px;
  background: rgba(15, 23, 42, 0.7);
  border-bottom: 1px solid #334155;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.modal-title {
  font-size: 14px;
  font-weight: 700;
  color: #fff;
}
.close-btn {
  background: none;
  border: none;
  color: #94a3b8;
  font-size: 20px;
  cursor: pointer;
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 6px;
}
.close-btn:active {
  background: rgba(51, 65, 85, 0.5);
}
.modal-body {
  padding: 12px;
  overflow-y: auto;
  max-height: calc(70vh - 50px);
}

/* Menu Items */
.menu-item {
  padding: 12px 14px;
  border-bottom: 1px solid #334155;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 12px;
  border-radius: 8px;
  margin-bottom: 4px;
}
.menu-item:active {
  background: rgba(30, 41, 59, 0.7);
}
.menu-icon-wrapper {
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(51, 65, 85, 0.3);
  border-radius: 6px;
}
.menu-text {
  font-size: 13px;
  color: #cbd5e1;
  font-weight: 500;
}

/* Settings */
.settings-group {
  margin-bottom: 14px;
}
.settings-label {
  display: block;
  margin-bottom: 6px;
  font-size: 12px;
  color: #94a3b8;
  font-weight: 500;
}
.color-input {
  width: 100%;
  padding: 8px 10px;
  background: #334155;
  border: 1px solid #475569;
  border-radius: 6px;
  color: #cbd5e1;
  font-size: 12px;
  height: 36px;
}

/* Search */
.search-container {
  margin-bottom: 12px;
  position: relative;
}
.search-input {
  width: 100%;
  padding: 10px 10px 10px 36px;
  background: #334155;
  border: 1px solid #475569;
  border-radius: 8px;
  color: #cbd5e1;
  font-size: 13px;
  height: 40px;
}
.search-icon {
  position: absolute;
  left: 10px;
  top: 50%;
  transform: translateY(-50%);
  color: #94a3b8;
  width: 18px;
  height: 18px;
}

/* Timeframes Grid - ALL TIMEFRAMES */
.timeframes-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 8px;
}
.timeframe-btn {
  padding: 12px 4px;
  background: #334155;
  border: 1px solid #475569;
  border-radius: 6px;
  color: #cbd5e1;
  font-size: 11px;
  cursor: pointer;
  text-align: center;
  font-weight: 600;
  transition: all 0.2s;
}
.timeframe-btn:active {
  transform: scale(0.95);
  background: #475569;
}
.timeframe-btn.active {
  background: rgba(77, 255, 204, 0.25);
  border-color: #4dffcc;
  color: #4dffcc;
}

/* Price Line */
.price-line {
  position: absolute;
  left: 0;
  right: 50px;
  height: 1px;
  background: repeating-linear-gradient(
    to right,
    currentColor,
    currentColor 4px,
    transparent 4px,
    transparent 8px
  );
  pointer-events: none;
  z-index: 50;
  opacity: 0.8;
}

/* Last Price Label - INSIDE PRICE AXIS */
.last-price-label {
  position: absolute;
  right: 0;
  width: 50px;
  transform: translateY(-50%);
  color: white;
  padding: 3px 4px;
  font-size: 9px;
  font-weight: bold;
  font-family: 'SF Mono', monospace;
  white-space: nowrap;
  z-index: 60;
  text-align: center;
  border-left: 2px solid rgba(255,255,255,0.3);
}
.last-price-label .price {
  display: block;
  font-size: 9px;
  margin-bottom: 1px;
}
.last-price-label .timer {
  font-size: 8px;
  opacity: 0.9;
}

/* Indicator List */
.indicator-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px;
  border-bottom: 1px solid #334155;
  border-radius: 8px;
  margin-bottom: 4px;
  background: rgba(30, 41, 59, 0.5);
}
.indicator-badge {
  background: #4dffcc;
  color: #000;
  padding: 3px 8px;
  border-radius: 12px;
  font-size: 10px;
  font-weight: 700;
}
.indicator-actions {
  display: flex;
  gap: 6px;
}
.indicator-btn {
  width: 28px;
  height: 28px;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  background: #334155;
  color: #cbd5e1;
  border: none;
}
.indicator-btn.settings { 
  background: #4dffcc; 
  color: #000; 
}

/* Symbols List */
.symbols-list {
  max-height: 50vh;
  overflow-y: auto;
}
.symbol-item {
  padding: 10px 12px;
  border-radius: 8px;
  cursor: pointer;
  margin-bottom: 4px;
  background: rgba(30, 41, 59, 0.5);
  border: 1px solid transparent;
}
.symbol-item:active {
  background: rgba(51, 65, 85, 0.7);
  border-color: #4dffcc;
}
.symbol-name {
  font-size: 12px;
  color: #cbd5e1;
  font-weight: 600;
}

/* Top Bar Info - BESIDE PRICE AXIS */
#top-bar-info {
  position: absolute;
  top: 6px;
  right: 55px;
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 2px;
  z-index: 200;
  pointer-events: none;
  background: rgba(15, 23, 42, 0.8);
  padding: 4px 8px;
  border-radius: 6px;
  backdrop-filter: blur(4px);
}
.top-symbol {
  font-size: 11px;
  font-weight: 700;
  color: #fff;
  letter-spacing: -0.2px;
  text-align: right;
}
.top-timeframe {
  font-size: 9px;
  color: #94a3b8;
  background: rgba(51, 65, 85, 0.5);
  padding: 1px 5px;
  border-radius: 3px;
}
</style>
</head>
<body>
<div id="chart-container">
<canvas id="main-canvas"></canvas>
<canvas id="price-canvas"></canvas>
<canvas id="time-canvas"></canvas>
<div id="corner"></div>

<!-- Top Bar Info - BESIDE PRICE AXIS -->
<div id="top-bar-info">
  <span class="top-symbol" id="top-symbol">EUR/USD</span>
  <span class="top-timeframe" id="top-timeframe">1m</span>
</div>

<div id="loading">
<div class="spinner"></div>
<div style="color: #94a3b8; font-size: 11px;">Loading...</div>
</div>

<!-- Menu Button - TOP LEFT -->
<div id="menu-button">
<div class="square-menu-icon">
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
</div>
</div>

<!-- Price Line -->
<div class="price-line" id="price-line"></div>
<!-- Last Price Label - INSIDE PRICE AXIS -->
<div class="last-price-label" id="last-price-label">
<span class="price">--</span>
<span class="timer">--:--</span>
</div>

<!-- Menu Modal -->
<div id="menu-modal" class="modal-overlay">
<div class="modal-card">
<div class="modal-header">
<div class="modal-title">Menu</div>
<button class="close-btn" id="menu-close">×</button>
</div>
<div class="modal-body">
<div class="menu-item" data-action="symbols">
<div class="menu-icon-wrapper">
<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#cbd5e1" stroke-width="2">
<path d="M12 2L2 7l10 5 10-5-10-5z"/>
<path d="M2 17l10 5 10-5"/>
<path d="M2 12l10 5 10-5"/>
</svg>
</div>
<span class="menu-text">Symbols</span>
</div>
<div class="menu-item" data-action="timeframes">
<div class="menu-icon-wrapper">
<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#cbd5e1" stroke-width="2">
<circle cx="12" cy="12" r="10"/>
<polyline points="12,6 12,12 16,14"/>
</svg>
</div>
<span class="menu-text">Timeframes</span>
</div>
<div class="menu-item" data-action="indicators">
<div class="menu-icon-wrapper">
<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#cbd5e1" stroke-width="2">
<polyline points="22,12 18,12 15,21 9,3 6,12 2,12"/>
</svg>
</div>
<span class="menu-text">Indicators</span>
</div>
<div class="menu-item" data-action="settings">
<div class="menu-icon-wrapper">
<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#cbd5e1" stroke-width="2">
<circle cx="12" cy="12" r="3"/>
<path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
</svg>
</div>
<span class="menu-text">Settings</span>
</div>
</div>
</div>
</div>

<!-- Indicators Modal -->
<div id="indicators-modal" class="modal-overlay">
  <div class="modal-card">
    <div class="modal-header">
      <div class="modal-title">Indicators</div>
      <button class="close-btn" id="indicators-close">×</button>
    </div>
    <div class="modal-body" id="indicators-list">
    </div>
  </div>
</div>

<!-- Indicator Settings Panel -->
<div id="indicator-settings-panel" class="modal-overlay">
  <div class="modal-card">
    <div class="modal-header">
      <div class="modal-title">MA Settings</div>
      <button class="close-btn" id="settings-panel-close">×</button>
    </div>
    <div class="modal-body">
      <div class="settings-group">
        <label class="settings-label">Period</label>
        <input type="range" min="5" max="100" value="20" class="color-input" id="ma-period" style="height: 24px;">
        <div style="text-align: center; margin-top: 4px; color: #94a3b8; font-size: 11px;" id="ma-period-value">20</div>
      </div>
      <div class="settings-group">
        <label class="settings-label">Color</label>
        <input type="color" class="color-input" id="ma-color" value="#4dffcc">
      </div>
      <div style="margin-top: 16px; text-align: center;">
        <button id="apply-ma-settings" class="timeframe-btn" style="width: 100%; padding: 10px; font-size: 12px;">Apply</button>
      </div>
    </div>
  </div>
</div>

<!-- Settings Modal -->
<div id="settings-modal" class="modal-overlay">
<div class="modal-card">
<div class="modal-header">
<div class="modal-title">Settings</div>
<button class="close-btn" id="settings-close">×</button>
</div>
<div class="modal-body">
<div class="settings-group">
<label class="settings-label">Background</label>
<input type="color" class="color-input" id="bg-color" value="#0f172a">
</div>
<div class="settings-group">
<label class="settings-label">Bullish Color</label>
<input type="color" class="color-input" id="up-color" value="#00C510">
</div>
<div class="settings-group">
<label class="settings-label">Bearish Color</label>
<input type="color" class="color-input" id="down-color" value="#ff0000">
</div>
</div>
</div>
</div>

<!-- Timeframes Modal - ALL TIMEFRAMES -->
<div id="timeframes-modal" class="modal-overlay">
<div class="modal-card">
<div class="modal-header">
<div class="modal-title">Timeframes</div>
<button class="close-btn" id="timeframes-close">×</button>
</div>
<div class="modal-body">
<div class="timeframes-grid" id="timeframes-grid">
<!-- All timeframes will be generated here -->
</div>
</div>
</div>
</div>

<!-- Symbols Modal with Search -->
<div id="symbols-modal" class="modal-overlay">
<div class="modal-card">
<div class="modal-header">
<div class="modal-title">Symbols</div>
<button class="close-btn" id="symbols-close">×</button>
</div>
<div class="modal-body">
<div class="search-container">
<svg class="search-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
<circle cx="11" cy="11" r="8"/>
<path d="M21 21l-4.35-4.35"/>
</svg>
<input type="text" class="search-input" id="symbol-search" placeholder="Search...">
</div>
<div class="symbols-list" id="symbols-list">
</div>
</div>
</div>
</div>
</div>

<script>
// ======================
// Global Variables
// ======================
let currentAsset = "EUR/USD";
let currentTimeframe = "1m";
let timeframeSeconds = 60;

// ALL TIMEFRAMES
const TIMEFRAMES = {
  "5s": 5,
  "10s": 10,
  "15s": 15,
  "30s": 30,
  "1m": 60,
  "2m": 120,
  "3m": 180,
  "5m": 300,
  "10m": 600,
  "15m": 900,
  "30m": 1800,
  "1h": 3600,
  "4h": 14400
};

const CONFIG = {
candleCount: 100,
defaultBarSpacing: 8,
minBarSpacing: 2,
maxBarSpacing: 30,
priceDecimals: 5,
colors: {
bg: '#0f172a',
grid: '#334155',
crosshair: '#94a3b8',
up: '#00C510',
down: '#ff0000',
ma: '#4dffcc'
},
maPeriod: 20,
maColor: '#4dffcc',
maEnabled: true
};

const FONTS = {
price: '10px sans-serif',
time: '9px sans-serif'
};

// ======================
// Fake Data Generator
// ======================
class FakeDataGenerator {
  constructor() {
    this.lastPrice = 1.08500;
    this.candles = [];
    this.currentCandle = null;
    this.generateInitialCandles();
  }
  
  generateInitialCandles() {
    const now = Math.floor(Date.now() / 1000);
    const count = CONFIG.candleCount;
    
    for (let i = count; i > 0; i--) {
      const time = now - (i * timeframeSeconds);
      this.addHistoricalCandle(time);
    }
    
    this.createNewCandle(now);
  }
  
  addHistoricalCandle(time) {
    const volatility = 0.0002;
    const open = this.lastPrice;
    const change = (Math.random() - 0.5) * volatility;
    const close = open + change;
    const high = Math.max(open, close) + Math.random() * volatility * 0.5;
    const low = Math.min(open, close) - Math.random() * volatility * 0.5;
    
    this.candles.push({
      time: time,
      open: open,
      high: high,
      low: low,
      close: close,
      isClosed: true
    });
    this.lastPrice = close;
  }
  
  createNewCandle(time) {
    this.currentCandle = {
      time: time,
      open: this.lastPrice,
      high: this.lastPrice,
      low: this.lastPrice,
      close: this.lastPrice,
      isClosed: false
    };
    this.candles.push(this.currentCandle);
  }
  
  updateCurrentCandle() {
    const now = Math.floor(Date.now() / 1000);
    
    if (now >= this.currentCandle.time + timeframeSeconds) {
      this.currentCandle.isClosed = true;
      this.lastPrice = this.currentCandle.close;
      const newTime = this.currentCandle.time + timeframeSeconds;
      this.createNewCandle(newTime);
      return { type: 'new', candle: this.currentCandle };
    } else {
      const volatility = 0.00015;
      const change = (Math.random() - 0.5) * volatility;
      let newClose = this.currentCandle.close + change;
      
      this.currentCandle.close = newClose;
      this.currentCandle.high = Math.max(this.currentCandle.high, newClose);
      this.currentCandle.low = Math.min(this.currentCandle.low, newClose);
      
      return { type: 'update', candle: this.currentCandle };
    }
  }
  
  getCandles() {
    return this.candles;
  }
}

// ======================
// TimeScale Class
// ======================
class TimeScale {
constructor() {
this.barSpacing = CONFIG.defaultBarSpacing;
this.offset = 0;
this.data = [];
}
setData(data) {
this.data = data;
}
indexToX(index) {
return this.offset + (index * this.barSpacing);
}
xToIndex(x) {
return (x - this.offset) / this.barSpacing;
}
getVisibleRange(width) {
const startIdx = Math.floor(this.xToIndex(0));
const endIdx = Math.ceil(this.xToIndex(width));
return {
start: Math.max(0, startIdx),
end: Math.min(this.data.length - 1, endIdx)
};
}
scroll(delta) {
this.offset += delta;
}
zoom(factor, centerX, width) {
const oldSpacing = this.barSpacing;
const newSpacing = Math.max(CONFIG.minBarSpacing,
Math.min(CONFIG.maxBarSpacing, oldSpacing * factor));
const centerIdx = this.xToIndex(centerX);
this.barSpacing = newSpacing;
const newCenterX = this.indexToX(centerIdx);
this.offset += (centerX - newCenterX);
}
}

// ======================
// PriceScale Class
// ======================
class PriceScale {
constructor() {
this.min = 0;
this.max = 0;
this.margin = 0.05;
}
calculate(candles, startIdx, endIdx) {
let min = Infinity;
let max = -Infinity;
startIdx = Math.max(0, startIdx);
endIdx = Math.min(candles.length - 1, endIdx);
for (let i = startIdx; i <= endIdx; i++) {
const c = candles[i];
if (c) {
min = Math.min(min, c.low);
max = Math.max(max, c.high);
}
}
if (min === Infinity) {
min = 0;
max = 100;
}
const range = max - min;
const safeRange = range < 0.0001 ? 0.0001 : range;
this.min = min - (safeRange * this.margin);
this.max = max + (safeRange * this.margin);
}
priceToY(price, height) {
const range = this.max - this.min;
const ratio = (price - this.min) / range;
return height - (ratio * height);
}
}

// ======================
// MainRenderer Class
// ======================
class MainRenderer {
constructor(canvas) {
this.canvas = canvas;
this.ctx = canvas.getContext('2d');
this.dpr = Math.min(window.devicePixelRatio || 1, 2);
}
resize(width, height) {
this.width = width;
this.height = height;
this.canvas.width = Math.floor(width * this.dpr);
this.canvas.height = Math.floor(height * this.dpr);
this.canvas.style.width = `${width}px`;
this.canvas.style.height = `${height}px`;
this.ctx.setTransform(1, 0, 0, 1, 0, 0);
this.ctx.scale(this.dpr, this.dpr);
}
clear() {
this.ctx.fillStyle = CONFIG.colors.bg;
this.ctx.fillRect(0, 0, this.width, this.height);
}
drawGrid(priceScale, timeScale) {
const { ctx, width, height } = this;
ctx.strokeStyle = CONFIG.colors.grid;
ctx.lineWidth = 0.5;
const priceRange = priceScale.max - priceScale.min;
const step = priceRange / 5;
for (let i = 0; i <= 5; i++) {
const price = priceScale.min + (step * i);
const y = priceScale.priceToY(price, height);
ctx.beginPath();
ctx.moveTo(0, y);
ctx.lineTo(width, y);
ctx.stroke();
}
const visible = timeScale.getVisibleRange(width);
const timeStep = Math.max(1, Math.floor((visible.end - visible.start) / 4));
for (let i = visible.start; i <= visible.end; i += timeStep) {
const x = timeScale.indexToX(i);
if (x < 0 || x > width) continue;
ctx.beginPath();
ctx.moveTo(x, 0);
ctx.lineTo(x, height);
ctx.stroke();
}
}
drawCandles(candles, timeScale, priceScale) {
const { ctx, width, height } = this;
const visible = timeScale.getVisibleRange(width);
const candleWidth = Math.max(1, timeScale.barSpacing * 0.65);

for (let i = visible.start; i <= visible.end; i++) {
const c = candles[i];
if (!c) continue;
  
const x = timeScale.indexToX(i);
if (x < -candleWidth || x > width + candleWidth) continue;

const yOpen = priceScale.priceToY(c.open, height);
const yHigh = priceScale.priceToY(c.high, height);
const yLow = priceScale.priceToY(c.low, height);
const yClose = priceScale.priceToY(c.close, height);

const isUp = c.close >= c.open;
const color = isUp ? CONFIG.colors.up : CONFIG.colors.down;

// Wick
ctx.strokeStyle = color;
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(x, yHigh);
ctx.lineTo(x, yLow);
ctx.stroke();

// Body
ctx.fillStyle = color;
const bodyTop = Math.min(yOpen, yClose);
const bodyHeight = Math.max(1, Math.abs(yClose - yOpen));
ctx.fillRect(x - candleWidth/2, bodyTop, candleWidth, bodyHeight);
}
}
drawMovingAverage(ma, timeScale, priceScale) {
if (!CONFIG.maEnabled) return;
const { ctx, width, height } = this;
const visible = timeScale.getVisibleRange(width);
ctx.strokeStyle = CONFIG.maColor;
ctx.lineWidth = 1.5;
ctx.beginPath();
let started = false;
for (let i = visible.start; i <= visible.end; i++) {
if (i >= ma.length || ma[i] === null) continue;
const x = timeScale.indexToX(i);
const y = priceScale.priceToY(ma[i], height);
if (!started) {
ctx.moveTo(x, y);
started = true;
} else {
ctx.lineTo(x, y);
}
}
ctx.stroke();
}
drawCrosshair(x, y) {
const { ctx, width, height } = this;
ctx.strokeStyle = CONFIG.colors.crosshair;
ctx.lineWidth = 0.5;
ctx.setLineDash([3, 3]);
ctx.beginPath();
ctx.moveTo(x, 0);
ctx.lineTo(x, height);
ctx.stroke();
ctx.beginPath();
ctx.moveTo(0, y);
ctx.lineTo(width, y);
ctx.stroke();
ctx.setLineDash([]);
}
}

// ======================
// PriceAxisRenderer Class
// ======================
class PriceAxisRenderer {
constructor(canvas) {
this.canvas = canvas;
this.ctx = canvas.getContext('2d');
this.dpr = Math.min(window.devicePixelRatio || 1, 2);
}
resize(width, height) {
this.canvas.width = Math.floor(width * this.dpr);
this.canvas.height = Math.floor(height * this.dpr);
this.canvas.style.width = `${width}px`;
this.canvas.style.height = `${height}px`;
this.ctx.setTransform(1, 0, 0, 1, 0, 0);
this.ctx.scale(this.dpr, this.dpr);
}
render(priceScale, height) {
const { ctx } = this;
const width = this.canvas.width / this.dpr;
ctx.clearRect(0, 0, width, height);
ctx.fillStyle = CONFIG.colors.bg;
ctx.fillRect(0, 0, width, height);
ctx.fillStyle = CONFIG.colors.text;
ctx.font = FONTS.price;
ctx.textAlign = 'left';
ctx.textBaseline = 'middle';
const priceRange = priceScale.max - priceScale.min;
const step = priceRange / 5;
for (let i = 0; i <= 5; i++) {
const price = priceScale.min + (step * i);
const y = priceScale.priceToY(price, height);
let text = price >= 1000 ? price.toFixed(0) : price.toFixed(CONFIG.priceDecimals);
if (text.length > 7) text = text.substring(0, 7);
ctx.fillText(text, 4, y);
ctx.fillStyle = CONFIG.colors.grid;
ctx.fillRect(0, y - 0.5, 3, 1);
ctx.fillStyle = CONFIG.colors.text;
}
}
}

// ======================
// TimeAxisRenderer Class
// ======================
class TimeAxisRenderer {
constructor(canvas) {
this.canvas = canvas;
this.ctx = canvas.getContext('2d');
this.dpr = Math.min(window.devicePixelRatio || 1, 2);
}
resize(width, height) {
this.canvas.width = Math.floor(width * this.dpr);
this.canvas.height = Math.floor(height * this.dpr);
this.canvas.style.width = `${width}px`;
this.canvas.style.height = `${height}px`;
this.ctx.setTransform(1, 0, 0, 1, 0, 0);
this.ctx.scale(this.dpr, this.dpr);
}
render(timeScale, candles, width) {
const { ctx } = this;
const height = this.canvas.height / this.dpr;
ctx.clearRect(0, 0, width, height);
ctx.fillStyle = CONFIG.colors.bg;
ctx.fillRect(0, 0, width, height);
ctx.fillStyle = CONFIG.colors.text;
ctx.font = FONTS.time;
ctx.textAlign = 'center';
ctx.textBaseline = 'top';
const visible = timeScale.getVisibleRange(width);
const timeStep = Math.max(1, Math.floor((visible.end - visible.start) / 4));
for (let i = visible.start; i <= visible.end; i += timeStep) {
const x = timeScale.indexToX(i);
if (x < 20 || x > width - 20) continue;
const c = candles[i];
if (!c) continue;
const date = new Date(c.time * 1000);
const text = `${date.getHours().toString().padStart(2,'0')}:${date.getMinutes().toString().padStart(2,'0')}`;
ctx.fillText(text, x, 4);
ctx.fillStyle = CONFIG.colors.grid;
ctx.fillRect(x - 0.5, 0, 1, 3);
ctx.fillStyle = CONFIG.colors.text;
}
}
}

// ======================
// ModalManager Class
// ======================
class ModalManager {
constructor() {
this.modals = {
menu: document.getElementById('menu-modal'),
indicators: document.getElementById('indicators-modal'),
settings: document.getElementById('settings-modal'),
timeframes: document.getElementById('timeframes-modal'),
symbols: document.getElementById('symbols-modal')
};
this.initModals();
this.initTimeframes(); // ALL TIMEFRAMES
this.initSettings();
this.initIndicators();
this.initSymbols();
}
initModals() {
const menuBtn = document.getElementById('menu-button');
menuBtn.addEventListener('click', () => this.showModal('menu'));
menuBtn.addEventListener('touchstart', (e) => {
e.preventDefault();
this.showModal('menu');
});

Object.keys(this.modals).forEach(modalName => {
const closeBtn = document.getElementById(`${modalName}-close`);
if (closeBtn) {
closeBtn.addEventListener('click', () => this.hideModal(modalName));
}
});

document.querySelectorAll('.menu-item').forEach(item => {
item.addEventListener('click', (e) => {
const action = e.currentTarget.dataset.action;
this.hideModal('menu');
this.showModal(action);
});
});

Object.values(this.modals).forEach(modal => {
modal.addEventListener('click', (e) => {
if (e.target === modal) this.hideAllModals();
});
});
}
initTimeframes() {
const grid = document.getElementById('timeframes-grid');
Object.keys(TIMEFRAMES).forEach(tf => {
const btn = document.createElement('div');
btn.className = 'timeframe-btn';
btn.textContent = tf;
if (tf === currentTimeframe) btn.classList.add('active');
btn.addEventListener('click', () => {
document.querySelectorAll('.timeframe-btn').forEach(b => b.classList.remove('active'));
btn.classList.add('active');
selectTimeframe(tf);
});
grid.appendChild(btn);
});
}
initSettings() {
document.getElementById('bg-color').addEventListener('change', (e) => {
CONFIG.colors.bg = e.target.value;
});
document.getElementById('up-color').addEventListener('change', (e) => {
CONFIG.colors.up = e.target.value;
});
document.getElementById('down-color').addEventListener('change', (e) => {
CONFIG.colors.down = e.target.value;
});
}
initIndicators() {
const indicatorsList = document.getElementById('indicators-list');
const settingsPanel = document.getElementById('indicator-settings-panel');
const maPeriodInput = document.getElementById('ma-period');
const maPeriodValue = document.getElementById('ma-period-value');
const maColorInput = document.getElementById('ma-color');
const applyBtn = document.getElementById('apply-ma-settings');

function renderIndicatorList() {
indicatorsList.innerHTML = `
<div class="indicator-item">
<div class="indicator-info">
<div class="indicator-badge">MA</div>
<span style="font-size: 12px;">Moving Average</span>
</div>
<div class="indicator-actions">
<button class="indicator-btn settings">
<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
<circle cx="12" cy="12" r="3"/>
<path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
</svg>
</button>
<button class="indicator-btn toggle ${CONFIG.maEnabled ? '' : 'hidden'}">
<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
<circle cx="12" cy="12" r="3"/>
</svg>
</button>
</div>
</div>
`;

indicatorsList.querySelector('.settings').onclick = () => settingsPanel.classList.add('active');
indicatorsList.querySelector('.toggle').onclick = (e) => {
CONFIG.maEnabled = !CONFIG.maEnabled;
e.currentTarget.classList.toggle('hidden', !CONFIG.maEnabled);
chart.requestRender();
};
}

document.getElementById('settings-panel-close').onclick = () => settingsPanel.classList.remove('active');

applyBtn.onclick = () => {
CONFIG.maPeriod = parseInt(maPeriodInput.value);
CONFIG.maColor = maColorInput.value;
chart.calculateMA();
settingsPanel.classList.remove('active');
};

maPeriodInput.oninput = (e) => maPeriodValue.textContent = e.target.value;

renderIndicatorList();
}
initSymbols() {
const searchInput = document.getElementById('symbol-search');
const symbolsList = document.getElementById('symbols-list');
const self = this;

const fakeSymbols = ["EUR/USD", "GBP/USD", "USD/JPY", "AUD/USD", "USD/CAD", "USD/CHF", "NZD/USD", "EUR/GBP", "EUR/JPY", "GBP/JPY", "AUD/JPY", "EUR/AUD"];

function renderSymbols(filter = '') {
const filtered = fakeSymbols.filter(s => s.toLowerCase().includes(filter.toLowerCase()));
if (filtered.length === 0) {
symbolsList.innerHTML = '<div class="no-results">No symbols found</div>';
return;
}
symbolsList.innerHTML = '';
filtered.forEach((s) => {
const item = document.createElement('div');
item.className = 'symbol-item';
item.dataset.symbol = s;
item.innerHTML = `<span class="symbol-name">${s}</span>`;
symbolsList.appendChild(item);
});
symbolsList.querySelectorAll('.symbol-item').forEach(item => {
item.addEventListener('click', () => {
selectAsset(item.dataset.symbol);
self.hideModal('symbols');
});
});
}

searchInput.addEventListener('input', (e) => renderSymbols(e.target.value));
renderSymbols();
}
showModal(modalName) {
if (this.modals[modalName]) this.modals[modalName].classList.add('active');
}
hideModal(modalName) {
if (this.modals[modalName]) this.modals[modalName].classList.remove('active');
}
hideAllModals() {
Object.values(this.modals).forEach(modal => modal.classList.remove('active'));
}
}

// ======================
// UltraChart Class
// ======================
class UltraChart {
constructor() {
this.container = document.getElementById('chart-container');
this.mainCanvas = document.getElementById('main-canvas');
this.priceCanvas = document.getElementById('price-canvas');
this.timeCanvas = document.getElementById('time-canvas');
this.priceLine = document.getElementById('price-line');
this.lastPriceLabel = document.getElementById('last-price-label');
  
this.mainRenderer = new MainRenderer(this.mainCanvas);
this.priceRenderer = new PriceAxisRenderer(this.priceCanvas);
this.timeRenderer = new TimeAxisRenderer(this.timeCanvas);
this.timeScale = new TimeScale();
this.priceScale = new PriceScale();
  
this.candles = [];
this.ma = [];
this.crosshair = { x: -1, y: -1, active: false };
this.isDragging = false;
this.lastMouseX = 0;
this.chartWidth = 0;
this.chartHeight = 0;
this.renderPending = false;
this.priceScaleDirty = true;
this.autoScroll = true;
  
this.fakeGenerator = new FakeDataGenerator();
this.init();
}
  
init() {
this.candles = this.fakeGenerator.getCandles();
this.timeScale.setData(this.candles);
this.calculateDimensions();
this.setupEvents();
this.calculateMA();
this.stickToRight();
this.requestRender();
  
setTimeout(() => document.getElementById('loading').style.display = 'none', 300);
  
this.updateInterval = setInterval(() => this.updateData(), 1000);
}
  
updateData() {
const result = this.fakeGenerator.updateCurrentCandle();
const lastIdx = this.candles.length - 1;
this.candles[lastIdx] = result.candle;
  
if (result.type === 'new') this.calculateMA();
  
this.timeScale.setData(this.candles);
if (this.autoScroll) this.stickToRight();
this.priceScaleDirty = true;
this.requestRender();
}
  
calculateDimensions() {
const rect = this.container.getBoundingClientRect();
const priceAxisW = 50;
const timeAxisH = 25;
this.chartWidth = rect.width - priceAxisW;
this.chartHeight = rect.height - timeAxisH;
this.mainRenderer.resize(this.chartWidth, this.chartHeight);
this.priceRenderer.resize(priceAxisW, this.chartHeight);
this.timeRenderer.resize(this.chartWidth, timeAxisH);
this.priceScaleDirty = true;
this.requestRender();
}
  
setupEvents() {
const canvas = this.mainCanvas;

// Mouse
canvas.addEventListener('mousedown', (e) => {
this.isDragging = true;
this.autoScroll = false;
this.lastMouseX = e.clientX;
canvas.style.cursor = 'grabbing';
});
  
window.addEventListener('mousemove', (e) => {
const rect = canvas.getBoundingClientRect();
this.crosshair.x = e.clientX - rect.left;
this.crosshair.y = e.clientY - rect.top;
this.crosshair.active = true;
if (this.isDragging) {
this.timeScale.scroll(e.clientX - this.lastMouseX);
this.lastMouseX = e.clientX;
this.priceScaleDirty = true;
this.requestRender();
}
});
  
window.addEventListener('mouseup', () => {
this.isDragging = false;
canvas.style.cursor = 'crosshair';
});
  
canvas.addEventListener('mouseleave', () => {
this.crosshair.active = false;
this.requestRender();
});
  
canvas.addEventListener('wheel', (e) => {
e.preventDefault();
this.timeScale.zoom(e.deltaY > 0 ? 0.9 : 1.1, this.crosshair.x, this.chartWidth);
this.priceScaleDirty = true;
this.requestRender();
});

// Touch
canvas.addEventListener('touchstart', (e) => {
if (e.touches.length === 1) {
this.isDragging = true;
this.autoScroll = false;
this.lastMouseX = e.touches[0].clientX;
}
}, {passive: false});
  
canvas.addEventListener('touchmove', (e) => {
e.preventDefault();
if (e.touches.length === 1) {
const touch = e.touches[0];
const rect = canvas.getBoundingClientRect();
this.crosshair.x = touch.clientX - rect.left;
this.crosshair.y = touch.clientY - rect.top;
this.crosshair.active = true;
if (this.isDragging) {
this.timeScale.scroll(touch.clientX - this.lastMouseX);
this.lastMouseX = touch.clientX;
this.priceScaleDirty = true;
this.requestRender();
}
}
}, {passive: false});
  
canvas.addEventListener('touchend', () => this.isDragging = false);

// Pinch zoom
let initialPinchDistance = null;
canvas.addEventListener('touchstart', (e) => {
if (e.touches.length === 2) {
initialPinchDistance = Math.hypot(
e.touches[0].clientX - e.touches[1].clientX,
e.touches[0].clientY - e.touches[1].clientY
);
}
}, {passive: false});
  
canvas.addEventListener('touchmove', (e) => {
if (e.touches.length === 2 && initialPinchDistance) {
e.preventDefault();
const currentDistance = Math.hypot(
e.touches[0].clientX - e.touches[1].clientX,
e.touches[0].clientY - e.touches[1].clientY
);
const factor = currentDistance / initialPinchDistance;
const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - canvas.getBoundingClientRect().left;
this.timeScale.zoom(factor, centerX, this.chartWidth);
initialPinchDistance = currentDistance;
this.priceScaleDirty = true;
this.requestRender();
}
}, {passive: false});
  
window.addEventListener('resize', () => this.calculateDimensions());
}
  
updatePriceLineAndLabel() {
if (this.candles.length === 0) return;
  
const lastCandle = this.candles[this.candles.length - 1];
const lastPrice = lastCandle.close;
const isUp = lastCandle.close >= lastCandle.open;
  
let lastPriceY = this.priceScale.priceToY(lastPrice, this.chartHeight);
if (!isFinite(lastPriceY)) lastPriceY = this.chartHeight / 2;
lastPriceY = Math.max(0, Math.min(this.chartHeight, lastPriceY));
  
// Update price line (dotted line across chart)
this.priceLine.style.top = `${lastPriceY}px`;
this.priceLine.style.color = isUp ? CONFIG.colors.up : CONFIG.colors.down;
  
// Update label (inside price axis on the right)
this.lastPriceLabel.style.top = `${lastPriceY}px`;
this.lastPriceLabel.style.backgroundColor = isUp ? CONFIG.colors.up : CONFIG.colors.down;
this.lastPriceLabel.querySelector('.price').textContent = lastPrice.toFixed(CONFIG.priceDecimals);
  
const now = Math.floor(Date.now() / 1000);
const elapsed = now - lastCandle.time;
const remaining = Math.max(0, timeframeSeconds - elapsed);
const minutes = Math.floor(remaining / 60);
const seconds = Math.floor(remaining % 60);
this.lastPriceLabel.querySelector('.timer').textContent =
`${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`;
}
  
calculateMA() {
this.ma = [];
for (let i = 0; i < this.candles.length; i++) {
if (i < CONFIG.maPeriod - 1) {
this.ma.push(null);
} else {
let sum = 0;
for (let j = 0; j < CONFIG.maPeriod; j++) sum += this.candles[i - j].close;
this.ma.push(sum / CONFIG.maPeriod);
}
}
}
  
requestRender() {
if (this.renderPending) return;
this.renderPending = true;
requestAnimationFrame(() => {
this.renderPending = false;
this.render();
});
}
  
stickToRight() {
this.timeScale.offset = this.chartWidth - (this.candles.length * this.timeScale.barSpacing);
}
  
render() {
const { chartWidth: w, chartHeight: h } = this;
const visible = this.timeScale.getVisibleRange(w);
  
if (this.priceScaleDirty) {
this.priceScale.calculate(this.candles, visible.start, visible.end);
this.priceScaleDirty = false;
}
  
this.mainRenderer.clear();
this.mainRenderer.drawGrid(this.priceScale, this.timeScale);
this.mainRenderer.drawCandles(this.candles, this.timeScale, this.priceScale);
this.mainRenderer.drawMovingAverage(this.ma, this.timeScale, this.priceScale);
  
if (this.crosshair.active) {
this.mainRenderer.drawCrosshair(this.crosshair.x, this.crosshair.y);
}
  
this.priceRenderer.render(this.priceScale, h);
this.timeRenderer.render(this.timeScale, this.candles, w);
this.updatePriceLineAndLabel();
}
}

// ======================
// Global Functions
// ======================
function selectAsset(asset) {
currentAsset = asset;
document.getElementById('top-symbol').textContent = currentAsset;
chart.fakeGenerator = new FakeDataGenerator();
chart.candles = chart.fakeGenerator.getCandles();
chart.timeScale.setData(chart.candles);
chart.calculateMA();
chart.stickToRight();
chart.requestRender();
}

function selectTimeframe(tf) {
currentTimeframe = tf;
timeframeSeconds = TIMEFRAMES[currentTimeframe];
document.getElementById('top-timeframe').textContent = currentTimeframe;
chart.fakeGenerator = new FakeDataGenerator();
chart.candles = chart.fakeGenerator.getCandles();
chart.timeScale.setData(chart.candles);
chart.calculateMA();
chart.stickToRight();
chart.requestRender();
}

// ======================
// Initialization
// ======================
const chart = new UltraChart();
const modalManager = new ModalManager();

document.getElementById('top-symbol').textContent = currentAsset;
document.getElementById('top-timeframe').textContent = currentTimeframe;
</script>
</body>
</html>
